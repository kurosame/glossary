## category

hardware

## titles

Memory
メモリ

## description

### メモリ領域

メモリ領域は以下 4 つの領域に分かれている  
開発の際にはヒープ領域とスタック領域を意識する

- プログラム領域  
  プログラムを格納

- 静的領域  
  グローバル変数などを格納

- ヒープ領域  
   動的に管理される領域の格納（new 演算子などの領域）  
   実行時にならないと正確なメモリサイズを判断できないため、動的にメモリを確保しておく  
   クラスの実態やオブジェクトを保持している  
   必ずポインターのアドレス（スタック領域）から参照するので、速度は若干落ちる

  - メモリリーク  
    ルートからアクセス可能の状態で残っており、GC で処理できない  
    JS だと v8 でオブジェクトを開放できない時に発生する

- スタック領域  
  プリミティブ型データやポインタアドレスを格納  
  プリミティブ型データはスタック領域に値をそのまま保持し、オブジェクト型データはスタック領域にポインタアドレスだけがあり、実際のデータはヒープ領域にある状態  
  そのまま使える為、高速

### ライフサイクル

- メモリ割り当て  
  メモリは OS によって割り当てられ、プログラムで使用できるようになる  
  低水準言語（C など）では開発者が必要な時に明示的に行う必要がある  
  高水準言語では言語が自動で割り当てる

- メモリ使用  
  プログラムが実際に割り当てたメモリを使うこと  
  たとえばコード上の変数割り当てが使用される際に、読み出しおよび書き込みの操作が行われる

- メモリ解放  
  不要なメモリが解放され、そのメモリを再度利用することができる状態  
  低水準言語では開発者が明示的にメモリを解放する  
  高水準言語では GC で自動的にメモリから解放してくれる

### GC の仕組み

ヒープ領域内では新しいデータと古いデータで内部的に分けて管理されている

新しいデータだけを対象にした GC を Minor GC と呼ぶ  
Minor GC は処理時間が短く、実行される頻度が高い  
一定回数 Minor GC で処理できなかったデータは、古いデータとして別の領域に保持される  
つまり、古いデータとは長期的に参照されているデータのことである

新しいデータと古いデータの両方を対象にした GC を Full GC と呼ぶ  
Full GC は古いデータも対象にしているので、Minor GC よりも時間がかかる

当然、Minor GC と Full GC 実行中は CPU を使用して処理しているので、アプリケーションのパフォーマンスに影響する  
Minor GC でメモリから解放されるように実装することで、Full GC の実行を抑えることができ、パフォーマンス改善に繋がる

### プリミティブ型の変数とオブジェクト型の変数

- プリミティブ型の変数

  - プログラミング言語などが仕様として提供する基本的なデータ型

    - JS だと string、number、boolean、undefined など
    - プリミティブ型は不変

      ```js
      let num = 3
      const add = i => (i += 1)
      add(num)
      console.log(num) // 3のまま（値渡しだから）

      // 再代入は可能
      // この場合、新しくメモリを割り当てている（つまり、元の値3はメモリに残ったままで不変）
      num = 4
      console.log(num) // 4になる
      ```

  - スタック領域に保存される

- オブジェクト型の変数
  - プリミティブ型以外はすべてオブジェクト型
    - JS だと array、object、function
  - オブジェクト型の変数を宣言した際はメモリを確保するが、コピーした際はメモリを確保せず、ポインターのアドレスのみが共有される
  - ポインターのアドレスはスタック領域に保存される
  - 値はヒープ領域に保存される

### Shallow Copy と Deep Copy

- Shallow Copy  
  オブジェクトを複製する際にコピー元とコピー先のオブジェクトが同じメモリを参照している  
  参照のコピーのみを行う

- Deep Copy  
  オブジェクトを複製する際にコピー元とコピー先のオブジェクトが違うメモリを参照している  
  メモリ領域を新たに確保してコピーを行う

JS で`Object.assign`やスプレッド構文を使ってオブジェクトを複製することができるが、オブジェクト内がネストしていた場合、1 層目は新しくメモリを確保して複製するが、2 層目は参照だけのコピーとなる（1 層目は Deep Copy で 2 層目が Shallow Copy みたいな）  
すべてのオブジェクトの要素を Deep Copy する場合は再帰的に`Object.assign`やスプレッド構文を使ってコピーするか、Lodash の`cloneDeep`を使う
